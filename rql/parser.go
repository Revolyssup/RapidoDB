package rql

import (
	"errors"
	"fmt"
	"strconv"
)

// Parser is the parser for RQL
type Parser struct {
	DisableHelpMsgs bool
}

func tokenFromKeyword(k keyword) token {
	return token{
		typ: keywordType,
		val: string(k),
	}
}

func tokenFromSymbol(s symbol) token {
	return token{
		typ: symbolType,
		val: string(s),
	}
}

func expectToken(tokens []*token, cursor uint, t token) bool {
	if cursor >= uint(len(tokens)) {
		return false
	}

	return t.equals(tokens[cursor])
}

func parseToken(tokens []*token, initialCursor uint, typ tokenType) (*token, uint, bool) {
	cursor := initialCursor

	if cursor >= uint(len(tokens)) {
		return nil, initialCursor, false
	}

	current := tokens[initialCursor]
	if current.typ == typ {
		return current, cursor + 1, true
	}

	return nil, initialCursor, false
}

func helpMessage(tokens []*token, cursor uint, msg string) string {
	var c *token
	if cursor < uint(len(tokens)) {
		c = tokens[cursor]
	} else {
		c = tokens[cursor-1]
	}

	return fmt.Sprintf("[%d,%d]: %s, got: %s\n", c.loc.line, c.loc.col, msg, c.val)
}

// Parse parses the tokens generated by the lexer and generates and AST
func Parse(source string) (*Ast, error) {
	tokens, err := lex(source)
	if err != nil {
		return nil, err
	}

	a := Ast{}
	cursor := uint(0)
	for cursor < uint(len(tokens)) {
		stmt, newCursor, ok, err := parseStatement(tokens, cursor, tokenFromSymbol(semicolonSymbol))
		if !ok {
			return nil, err
		}
		cursor = newCursor

		a.Statements = append(a.Statements, stmt)

		atLeastOneSemicolon := false
		for expectToken(tokens, cursor, tokenFromSymbol(semicolonSymbol)) {
			cursor++
			atLeastOneSemicolon = true
		}

		if !atLeastOneSemicolon {
			return nil, errors.New(helpMessage(tokens, cursor, "Expected semi-colon delimiter between statements"))
		}
	}

	return &a, nil
}

func parseStatement(tokens []*token, initialCursor uint, delimiter token) (*Statement, uint, bool, error) {
	cursor := initialCursor

	// Look for a SET statement
	semicolonToken := tokenFromSymbol(semicolonSymbol)
	set, newCursor, ok, err := parseSetStatement(tokens, cursor, semicolonToken)
	if ok || err != nil {
		return &Statement{
			Typ:          SetType,
			SetStatement: set,
		}, newCursor, true, err
	}

	// Look for a GET statement
	get, newCursor, ok, err := parseGetStatement(tokens, cursor, semicolonToken)
	if ok || err != nil {
		return &Statement{
			Typ:          GetType,
			GetStatement: get,
		}, newCursor, true, err
	}

	// Look for a DEL statement
	del, newCursor, ok, err := parseDeleteStatement(tokens, cursor, semicolonToken)
	if ok || err != nil {
		return &Statement{
			Typ:             DeleteType,
			DeleteStatement: del,
		}, newCursor, true, err
	}

	// Look for a AUTH statement
	auth, newCursor, ok, err := parseAuthStatement(tokens, cursor, semicolonToken)
	if ok || err != nil {
		return &Statement{
			Typ:           AuthType,
			AuthStatement: auth,
		}, newCursor, true, err
	}

	return nil, initialCursor, false, nil
}

func parseSetStatement(tokens []*token, initialCursor uint, delimiter token) (*SetStatement, uint, bool, error) {
	// SET <key> <value> [expiry] [TODO: ADD COMPLEX EXPRESSIONS SUPPORT]
	cursor := initialCursor

	// Look for the SET keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(setKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	// Look for the key name
	key, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, initialCursor, false, errors.New(helpMessage(tokens, cursor, "Expected a key name"))
	}
	cursor = newCursor

	// Look for the value
	val, newCursor, ok := parseExpression(tokens, cursor)
	if !ok {
		return nil, initialCursor, false, errors.New(helpMessage(tokens, cursor, "Expected a value"))
	}
	cursor = newCursor

	// Search for optional expiry
	exp, newCursor, ok := parseToken(tokens, cursor, numericType)
	if !ok {
		return &SetStatement{
			key: key.val,
			val: val.val,
		}, cursor, true, nil
	}

	expVal, err := strconv.ParseUint(exp.val, 10, 32)
	if err != nil {
		return nil, cursor, false, errors.New(helpMessage(tokens, cursor, "Invalid expiry provided"))
	}
	cursor = newCursor

	return &SetStatement{key.val, val.val, uint(expVal)}, cursor, true, nil
}

func parseGetStatement(tokens []*token, initialCursor uint, delimiter token) (*GetStatement, uint, bool, error) {
	// GET key1 key2 ...
	cursor := initialCursor

	// Look for the GET keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(getKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	keys := []string{}

	for {
		key, newCursor, ok := parseToken(tokens, cursor, identifierType)
		if !ok {
			// Check if the token is semicolon
			if !expectToken(tokens, newCursor, tokenFromSymbol(semicolonSymbol)) {
				return nil, newCursor, false, errors.New(helpMessage(tokens, cursor, "Invalid key name"))
			}

			return &GetStatement{keys}, cursor, true, nil
		}

		keys = append(keys, key.val)
		cursor = newCursor
	}
}

func parseDeleteStatement(tokens []*token, initialCursor uint, delimiter token) (*DeleteStatement, uint, bool, error) {
	// DEL key1 key2 ...
	cursor := initialCursor

	// Look for the DEL keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(delKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	keys := []string{}

	for {
		key, newCursor, ok := parseToken(tokens, cursor, identifierType)
		if !ok {
			// Check if the token is semicolon
			if !expectToken(tokens, newCursor, tokenFromSymbol(semicolonSymbol)) {
				return nil, newCursor, false, errors.New(helpMessage(tokens, cursor, "Invalid key name"))
			}

			return &DeleteStatement{keys}, cursor, true, nil
		}

		keys = append(keys, key.val)
		cursor = newCursor
	}
}

func parseAuthStatement(tokens []*token, initialCursor uint, delimiter token) (*AuthStatement, uint, bool, error) {
	// AUTH <username> <password>
	cursor := initialCursor

	// Look for the AUTH keyword
	if !expectToken(tokens, cursor, tokenFromKeyword(authKeyword)) {
		return nil, initialCursor, false, nil
	}
	cursor++

	// Look for the username
	username, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, cursor, false, errors.New(helpMessage(tokens, cursor, "username not found"))
	}
	cursor = newCursor

	// Look for the password
	password, newCursor, ok := parseToken(tokens, cursor, identifierType)
	if !ok {
		return nil, cursor, false, errors.New(helpMessage(tokens, cursor, "password not found"))
	}
	cursor = newCursor

	return &AuthStatement{username.val, password.val}, cursor, true, nil
}

func parseExpression(tokens []*token, initialCursor uint) (*token, uint, bool) {
	cursor := initialCursor

	types := []tokenType{identifierType, numericType, stringType}
	for _, typ := range types {
		t, newCursor, ok := parseToken(tokens, cursor, typ)
		if ok {
			return t, newCursor, true
		}
	}

	return nil, initialCursor, false
}
